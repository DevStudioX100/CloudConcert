// reserveWorker.js
import {
  DynamoDBClient,
  QueryCommand,
  UpdateItemCommand,
  PutItemCommand,
} from "@aws-sdk/client-dynamodb";

const client = new DynamoDBClient({ region: process.env.AWS_REGION || "us-east-1" });
const TABLE_ORDERS  = process.env.TABLE_ORDERS  || "cc-prd-dynamo-orders-table";
const TABLE_TICKETS = process.env.TABLE_TICKETS || "cc-prd-dynamo-tickets-table";
const GSI_EMAIL     = process.env.GSI_EMAIL     || "email_index";

export const handler = async (event = {}) => {
  console.log("SQS Event:", JSON.stringify(event));

  for (const record of event.Records) {
    const body = JSON.parse(record.body);
    const {
      order_id,
      created_at,
      email,
      ticket_type,
      quantity,
      status,
      full_name,
      dob,
      cccd,
    } = body;

    try {
      // 1) Check email (nếu có đơn pending thì từ chối)
      const q = await client.send(
        new QueryCommand({
          TableName: TABLE_ORDERS,
          IndexName: GSI_EMAIL,
          KeyConditionExpression: "email = :e",
          ExpressionAttributeValues: { ":e": { S: email } },
          Limit: 25,
        })
      );

      const existing = (q.Items || []).find(
        (i) => (i.status?.S || "").toLowerCase() === "pending"
      );
      if (existing) {
        console.warn(`❌ Email ${email} đã có đơn pending, bỏ qua.`);
        continue; // bỏ qua order này
      }

      // 2) Giảm tồn vé (atomic)
      await client.send(
        new UpdateItemCommand({
          TableName: TABLE_TICKETS,
          Key: { ticket_type: { S: ticket_type } },
          UpdateExpression: "SET remaining_quantity = remaining_quantity - :q",
          ConditionExpression: "remaining_quantity >= :q",
          ExpressionAttributeValues: { ":q": { N: String(quantity) } },
        })
      );

      // 3) Tạo order
      await client.send(
        new PutItemCommand({
          TableName: TABLE_ORDERS,
          Item: {
            order_id:    { S: order_id },
            created_at:  { S: created_at },
            email:       { S: email },
            ticket_type: { S: ticket_type },
            quantity:    { N: String(quantity) },
            status:      { S: status },
            payment_id:  { NULL: true },
            full_name:   { S: full_name },
            dob:         { S: dob },
            cccd:        { S: cccd },
          },
          ConditionExpression: "attribute_not_exists(order_id)",
        })
      );

      console.log(`✅ Order ${order_id} confirmed`);
    } catch (err) {
      console.error(`❌ Lỗi khi xử lý order ${order_id}:`, err);

      // Rollback vé nếu PutItem thất bại
      if (err.name !== "ConditionalCheckFailedException") {
        try {
          await client.send(
            new UpdateItemCommand({
              TableName: TABLE_TICKETS,
              Key: { ticket_type: { S: ticket_type } },
              UpdateExpression: "SET remaining_quantity = remaining_quantity + :q",
              ExpressionAttributeValues: { ":q": { N: String(quantity) } },
            })
          );
          console.log(`Rollback stock for ticket_type ${ticket_type}`);
        } catch (rbErr) {
          console.error("Rollback failed:", rbErr);
        }
      }
    }
  }
};
